<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>RecordRoute File Upload</title>
    <style>
        .warning-box {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            color: #856404;
        }
        .task-status {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            margin-left: 5px;
        }
        .status-running {
            background: #fff3cd;
            color: #856404;
        }
        .status-completed {
            background: #d4edda;
            color: #155724;
        }
        #workflow label {
            display: block;
            margin-bottom: 5px;
        }
        #textOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
        }
        #textOverlay .content {
            background: #ffffff;
            padding: 20px;
            max-width: 80%;
            max-height: 80%;
            overflow: auto;
            border-radius: 5px;
            position: relative;
        }
        #textOverlay .buttons {
            margin-bottom: 10px;
        }
        #textOverlay .buttons a,
        #textOverlay .buttons button {
            display: inline-block;
            padding: 5px 10px;
            margin-right: 5px;
            border: none;
            border-radius: 3px;
            text-decoration: none;
            cursor: pointer;
        }
        #overlayDownload {
            background: #007bff;
            color: white;
        }
        #overlayClose {
            background: #6c757d;
            color: white;
        }
        #summaryPopup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
        }
        #summaryPopup .content {
            background: #ffffff;
            padding: 20px;
            border-radius: 5px;
            text-align: center;
        }
        #summaryPopup button {
            margin: 0 5px;
            padding: 5px 10px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>Upload File</h1>
    <input type="file" id="fileInput" accept="audio/*,.md,.txt,.text,.markdown" multiple />
    <button id="uploadBtn">Upload</button>
    <div id="status"></div>

    <div id="workflow" style="display:none; margin-top:1em;">
        <label><input type="checkbox" id="stepStt" /> STT 변환</label>
        <label><input type="checkbox" id="stepCorrect" /> 텍스트 교정</label>
        <label><input type="checkbox" id="stepSummary" /> 요약</label>
        <button id="processBtn">확인</button>
    </div>

    <div id="downloads" style="margin-top:1em;"></div>

    <div id="queue-section" style="margin-top:2em;">
        <h2 style="display:flex; align-items:center; justify-content:space-between;">
            작업 큐
            <button id="cancelAllBtn" style="display:none; margin-left:auto; background:#dc3545; color:white; border:none; border-radius:3px; padding:4px 8px; cursor:pointer; font-size:14px;">모두 취소</button>
        </h2>
        <div id="queue-list"></div>
    </div>

    <div id="history-section" style="margin-top:2em;">
        <h2>업로드 기록</h2>
        <div id="history-list"></div>
    </div>

    <div id="search-section" style="margin-top:2em;">
        <h2>키워드 검색</h2>
        <input type="text" id="searchInput" placeholder="검색어를 입력하세요" />
        <button id="searchBtn">검색</button>
        <ul id="searchResults"></ul>
    </div>

    <div id="textOverlay">
        <div class="content">
            <div class="buttons">
                <a id="overlayDownload" href="#" download>다운로드</a>
                <button id="overlayClose">닫기</button>
            </div>
            <pre id="overlayContent" style="white-space: pre-wrap;"></pre>
        </div>
    </div>

    <div id="summaryPopup">
        <div class="content">
            <p>교정 작업을 진행한 뒤에 요약 작업을 시작하시겠습니까?</p>
            <button id="summaryOnlyBtn">요약만 진행</button>
            <button id="correctThenSummaryBtn">교정&gt;요약 순으로 진행</button>
        </div>
    </div>

    <script>
        let uploadedPath = null;
        let fileType = null;
        let recordId = null;
        let taskQueue = [];
        let currentTask = null;
        let taskIdCounter = 0;
        const categoryOrder = ['stt', 'correct', 'summary'];
        let currentCategory = null;
        const summaryPopup = document.getElementById('summaryPopup');
        const summaryOnlyBtn = document.getElementById('summaryOnlyBtn');
        const correctThenSummaryBtn = document.getElementById('correctThenSummaryBtn');

        function showTextOverlay(url) {
            const overlay = document.getElementById('textOverlay');
            const content = document.getElementById('overlayContent');
            const download = document.getElementById('overlayDownload');
            overlay.style.display = 'flex';
            content.textContent = '로딩중...';
            download.href = url;
            fetch(url)
                .then(resp => resp.text())
                .then(text => {
                    content.textContent = text;
                })
                .catch(() => {
                    content.textContent = '파일을 불러오지 못했습니다.';
                });
        }

        document.getElementById('overlayClose').addEventListener('click', () => {
            document.getElementById('textOverlay').style.display = 'none';
        });

        function hideSummaryPopup() {
            summaryPopup.style.display = 'none';
        }

        function setQueuedState(span) {
            span.style.backgroundColor = '#17a2b8';
            span.style.color = 'white';
            span.title = '큐에 추가됨';
            span.onclick = null;
        }

        function showSummaryPopup(record, span) {
            summaryPopup.style.display = 'flex';
            summaryOnlyBtn.onclick = () => {
                addTaskToQueue(record.id, record.file_path, 'summary', span, record.filename);
                setQueuedState(span);
                hideSummaryPopup();
            };
            correctThenSummaryBtn.onclick = () => {
                const correctSpan = span.parentNode.querySelector('span[data-task="correct"]');
                if (correctSpan) {
                    addTaskToQueue(record.id, record.file_path, 'correct', correctSpan, record.filename);
                    setQueuedState(correctSpan);
                } else {
                    addTaskToQueue(record.id, record.file_path, 'correct', document.createElement('span'), record.filename);
                }
                addTaskToQueue(record.id, record.file_path, 'summary', span, record.filename);
                setQueuedState(span);
                hideSummaryPopup();
            };
        }

        function sortTaskQueue() {
            let startIndex = 0;
            if (currentTask) {
                startIndex = categoryOrder.indexOf(currentTask.task);
            } else if (currentCategory) {
                startIndex = categoryOrder.indexOf(currentCategory);
            }
            const order = categoryOrder.slice(startIndex).concat(categoryOrder.slice(0, startIndex));
            taskQueue.sort((a, b) => {
                const diff = order.indexOf(a.task) - order.indexOf(b.task);
                return diff !== 0 ? diff : a.id - b.id;
            });
        }

        function formatDateTime(isoString) {
            const date = new Date(isoString);
            return date.toLocaleString('ko-KR', {
                year: 'numeric',
                month: '2-digit', 
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        }

        function addTaskToQueue(recordId, filePath, task, taskElement, filename) {
            const taskId = 'task_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);  // Generate unique task ID
            const taskItem = {
                id: ++taskIdCounter,
                taskId: taskId,  // Server-side task ID for cancellation
                recordId: recordId,
                filePath: filePath,
                task: task,
                taskElement: taskElement,
                filename: filename,
                status: 'queued',
                abortController: null
            };
            
            taskQueue.push(taskItem);
            sortTaskQueue();
            updateQueueDisplay();
            
            // Update history display to reflect queue state changes
            loadHistory();
            
            processNextTask();
            
            return taskItem.id;
        }

        function removeTaskFromQueue(taskId) {
            const taskIndex = taskQueue.findIndex(t => t.id === taskId);
            if (taskIndex !== -1) {
                const task = taskQueue[taskIndex];
                
                // If task is currently processing, send cancellation request to server
                if (task.status === 'processing' && task.taskId) {
                    fetch('/cancel', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ task_id: task.taskId })
                    }).then(response => response.json())
                    .then(result => {
                        console.log(`Task cancellation result for ${task.taskId}:`, result);
                    })
                    .catch(error => {
                        console.error(`Error cancelling task ${task.taskId}:`, error);
                    });
                }
                
                // Abort the request if it's in progress
                if (task.abortController) {
                    task.abortController.abort();
                }
                
                taskQueue.splice(taskIndex, 1);
                updateQueueDisplay();
                currentCategory = taskQueue.length > 0 ? taskQueue[0].task : currentCategory;
                
                // Reload history to restore button states properly
                loadHistory();
            }
            
            // If this was the current task, process next
            if (currentTask && currentTask.id === taskId) {
                currentTask = null;
                currentCategory = taskQueue.length > 0 ? taskQueue[0].task : null;
                processNextTask();
            }
        }

        function cancelAllTasks() {
            const tasks = [...taskQueue];
            tasks.forEach(t => removeTaskFromQueue(t.id));
        }

        document.getElementById('cancelAllBtn').addEventListener('click', cancelAllTasks);

        function resetTaskElement(taskElement, task) {
            const taskNames = {
                'stt': 'STT',
                'correct': '교정',
                'summary': '요약'
            };
            
            taskElement.textContent = taskNames[task] || task;
            taskElement.style.backgroundColor = '#6c757d';
            taskElement.style.color = 'white';
            taskElement.style.cursor = 'pointer';
            taskElement.title = '클릭하여 작업 시작';
        }

        function updateQueueDisplay() {
            const queueList = document.getElementById('queue-list');
            const cancelAllBtn = document.getElementById('cancelAllBtn');
            queueList.innerHTML = '';

            if (taskQueue.length === 0) {
                queueList.innerHTML = '<p style="color: #6c757d; font-style: italic;">진행 중인 작업이 없습니다.</p>';
                cancelAllBtn.style.display = 'none';
                return;
            }

            cancelAllBtn.style.display = 'inline-block';

            taskQueue.forEach((task, index) => {
                const item = document.createElement('div');
                item.style.cssText = `
                    border: 1px solid #dee2e6;
                    border-radius: 5px;
                    padding: 8px 12px;
                    margin-bottom: 5px;
                    background-color: ${task.status === 'processing' ? '#fff3cd' : '#f8f9fa'};
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                `;
                
                const taskNames = {
                    'stt': 'STT 변환',
                    'correct': '텍스트 교정',
                    'summary': '요약'
                };
                
                const statusText = task.status === 'processing' ? '진행중' : `대기중 (${index + 1}번째)`;
                const statusColor = task.status === 'processing' ? '#856404' : '#6c757d';
                
                const info = document.createElement('span');
                info.innerHTML = `
                    <strong>${task.filename}</strong> - ${taskNames[task.task] || task.task}
                    <span style="color: ${statusColor}; font-size: 12px; margin-left: 10px;">[${statusText}]</span>
                `;
                
                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = '×';
                cancelBtn.style.cssText = `
                    background: #dc3545;
                    color: white;
                    border: none;
                    border-radius: 3px;
                    width: 24px;
                    height: 24px;
                    cursor: pointer;
                    font-size: 16px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
                cancelBtn.title = '작업 취소';
                cancelBtn.onclick = () => removeTaskFromQueue(task.id);
                
                item.appendChild(info);
                item.appendChild(cancelBtn);
                queueList.appendChild(item);
            });
        }

        function createTaskElement(task, isCompleted, downloadUrl, record = null) {
            const taskNames = {
                'stt': 'STT',
                'correct': '교정',
                'summary': '요약'
            };
            
            const span = document.createElement('span');
            span.textContent = taskNames[task] || task;
            span.style.margin = '0 5px';
            span.style.padding = '2px 6px';
            span.style.borderRadius = '3px';
            span.style.fontSize = '12px';
            span.dataset.task = task;
            
            if (isCompleted && downloadUrl) {
                // Completed task - green with download link
                span.style.backgroundColor = '#28a745';
                span.style.color = 'white';
                span.style.cursor = 'pointer';
                span.style.textDecoration = 'underline';
                span.title = '클릭하여 내용 보기';
                span.onclick = () => {
                    showTextOverlay(downloadUrl);
                };
            } else if (record) {
                // Check if this task is already in queue
                const existingTask = taskQueue.find(t =>
                    t.recordId === record.id &&
                    t.task === task
                );
                
                if (existingTask) {
                    // Task is already in queue - show queued state
                    span.style.backgroundColor = '#17a2b8';
                    span.style.color = 'white';
                    span.style.cursor = 'default';
                    span.title = '큐에 추가됨';
                    span.onclick = null;
                } else {
                    // Incomplete task - clickable to add to queue or show popup
                    span.style.backgroundColor = '#6c757d';
                    span.style.color = 'white';
                    span.style.cursor = 'pointer';
                    span.title = '클릭하여 작업 시작';
                    span.onclick = () => {
                        // Double-check if this task is already in queue (in case of race condition)
                        const existingTaskCheck = taskQueue.find(t =>
                            t.recordId === record.id &&
                            t.task === task
                        );

                        if (!existingTaskCheck) {
                            if (task === 'summary' && record.completed_tasks.stt && !record.completed_tasks.correct) {
                                showSummaryPopup(record, span);
                            } else {
                                addTaskToQueue(record.id, record.file_path, task, span, record.filename);

                                // Show queued state
                                span.style.backgroundColor = '#17a2b8';
                                span.style.color = 'white';
                                span.title = '큐에 추가됨';
                                span.onclick = null;
                            }
                        }
                    };
                }
            } else {
                // Default state - not clickable
                span.style.backgroundColor = '#e9ecef';
                span.style.color = '#6c757d';
            }
            
            return span;
        }

        function displayHistory(history) {
            const historyList = document.getElementById('history-list');
            historyList.innerHTML = '';
            
            if (history.length === 0) {
                historyList.innerHTML = '<p style="color: #6c757d; font-style: italic;">업로드 기록이 없습니다.</p>';
                return;
            }
            
            history.forEach(record => {
                const item = document.createElement('div');
                item.style.cssText = `
                    border: 1px solid #dee2e6;
                    border-radius: 5px;
                    padding: 10px;
                    margin-bottom: 10px;
                    background-color: #f8f9fa;
                `;

                const typeLabel = record.file_type === 'audio' ? '오디오' : '텍스트';
                const dateTime = formatDateTime(record.timestamp);
                const duration = record.duration ? ` ${record.duration}` : '';

                const header = document.createElement('div');
                header.style.cssText = 'display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;';

                const info = document.createElement('span');
                info.innerHTML = `
                    <strong>[${typeLabel}]</strong>
                    ${dateTime}
                    <strong>${record.filename}</strong>${duration}
                `;

                const resetBtn = document.createElement('button');
                resetBtn.textContent = '초기화';
                resetBtn.style.cssText = `
                    background: #dc3545;
                    color: white;
                    border: none;
                    border-radius: 3px;
                    padding: 2px 8px;
                    cursor: pointer;
                    font-size: 12px;
                `;

                const hasCompleted = Object.values(record.completed_tasks).some(v => v);
                const queued = taskQueue.some(t => t.recordId === record.id);

                if (hasCompleted || queued) {
                    resetBtn.onclick = async () => {
                        if (!confirm('기존 작업내역을 초기화 하시겠습니까?')) return;

                        // Remove related tasks from queue
                        const relatedTasks = taskQueue.filter(t => t.recordId === record.id);
                        relatedTasks.forEach(t => removeTaskFromQueue(t.id));

                        const resp = await fetch('/reset', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ record_id: record.id })
                        });

                        if (resp.ok) {
                            loadHistory();
                        } else {
                            alert('초기화에 실패했습니다.');
                        }
                    };
                } else {
                    resetBtn.disabled = true;
                    resetBtn.style.background = '#6c757d';
                    resetBtn.style.cursor = 'not-allowed';
                }

                const batchBtn = document.createElement('button');
                batchBtn.textContent = '일괄 진행';
                batchBtn.style.cssText = `
                    background: #007bff;
                    color: white;
                    border: none;
                    border-radius: 3px;
                    padding: 2px 8px;
                    cursor: pointer;
                    font-size: 12px;
                    margin-right: 5px;
                `;

                const buttonContainer = document.createElement('div');
                buttonContainer.style.cssText = 'display:flex; align-items:center;';

                buttonContainer.appendChild(batchBtn);
                buttonContainer.appendChild(resetBtn);

                header.appendChild(info);
                header.appendChild(buttonContainer);

                const tasks = document.createElement('div');

                const taskElements = {};

                // Only show STT button for audio files
                if (record.file_type === 'audio') {
                    taskElements.stt = createTaskElement('stt', record.completed_tasks.stt, record.download_links.stt, record);
                    tasks.appendChild(taskElements.stt);
                }

                taskElements.correct = createTaskElement('correct', record.completed_tasks.correct, record.download_links.correct, record);
                tasks.appendChild(taskElements.correct);
                taskElements.summary = createTaskElement('summary', record.completed_tasks.summary, record.download_links.summary, record);
                tasks.appendChild(taskElements.summary);

                if (hasCompleted || queued) {
                    batchBtn.disabled = true;
                    batchBtn.style.background = '#6c757d';
                    batchBtn.style.cursor = 'not-allowed';
                } else {
                    batchBtn.onclick = () => {
                        const steps = [];
                        if (record.file_type === 'audio') steps.push('stt');
                        steps.push('correct', 'summary');

                        steps.forEach(step => {
                            const alreadyCompleted = record.completed_tasks[step];
                            const existingTask = taskQueue.find(t => t.recordId === record.id && t.task === step);
                            if (!alreadyCompleted && !existingTask) {
                                const span = taskElements[step] || document.createElement('span');
                                addTaskToQueue(record.id, record.file_path, step, span, record.filename);
                                if (taskElements[step]) {
                                    setQueuedState(taskElements[step]);
                                }
                            }
                        });

                        batchBtn.disabled = true;
                        batchBtn.style.background = '#6c757d';
                        batchBtn.style.cursor = 'not-allowed';
                    };
                }

                item.appendChild(header);
                if (record.title_summary) {
                    const summary = document.createElement('div');
                    summary.style.cssText = 'margin:4px 0; color:#333; font-size:13px;';
                    summary.textContent = record.title_summary;
                    item.appendChild(summary);
                }
                item.appendChild(tasks);
                historyList.appendChild(item);
            });
        }

        async function loadHistory() {
            try {
                const response = await fetch('/history');
                if (response.ok) {
                    const history = await response.json();
                    displayHistory(history);
                } else {
                    console.error('Failed to load history');
                }
            } catch (error) {
                console.error('Error loading history:', error);
            }
        }

        async function loadHistorySync() {
            try {
                const response = await fetch('/history');
                if (response.ok) {
                    return await response.json();
                }
                return [];
            } catch (error) {
                console.error('Error loading history:', error);
                return [];
            }
        }

        async function processNextTask() {
            if (currentTask || taskQueue.length === 0) {
                return;
            }
            
            currentTask = taskQueue[0];
            currentTask.status = 'processing';
            currentCategory = currentTask.task;
            updateQueueDisplay();
            
            try {
                // Show loading state on the task element
                const taskElement = currentTask.taskElement;
                const originalText = taskElement.textContent;
                taskElement.textContent = '처리중...';
                taskElement.style.backgroundColor = '#ffc107';
                taskElement.style.color = 'black';
                taskElement.style.cursor = 'default';
                taskElement.onclick = null;

                // Create AbortController for this task
                currentTask.abortController = new AbortController();

                const response = await fetch('/process', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        file_path: currentTask.filePath, 
                        steps: [currentTask.task],
                        record_id: currentTask.recordId,
                        task_id: currentTask.taskId  // Send task_id to server
                    }),
                    signal: currentTask.abortController.signal
                });

                if (response.ok) {
                    const result = await response.json();
                    
                    if (result.error) {
                        // Show error state
                        taskElement.textContent = '오류';
                        taskElement.style.backgroundColor = '#dc3545';
                        taskElement.style.color = 'white';
                        taskElement.title = `오류: ${result.error}`;
                    } else if (result[currentTask.task]) {
                        // Show success state with download link
                        taskElement.textContent = originalText;
                        taskElement.style.backgroundColor = '#28a745';
                        taskElement.style.color = 'white';
                        taskElement.style.cursor = 'pointer';
                        taskElement.style.textDecoration = 'underline';
                        taskElement.title = '클릭하여 다운로드';
                        taskElement.onclick = () => {
                            window.open(result[currentTask.task], '_blank');
                        };
                    }
                } else {
                    // Show error state
                    taskElement.textContent = '오류';
                    taskElement.style.backgroundColor = '#dc3545';
                    taskElement.style.color = 'white';
                    taskElement.title = '처리 중 오류가 발생했습니다';
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('Task was cancelled');
                } else {
                    // Show error state
                    const taskElement = currentTask.taskElement;
                    taskElement.textContent = '오류';
                    taskElement.style.backgroundColor = '#dc3545';
                    taskElement.style.color = 'white';
                    taskElement.title = `오류: ${error.message}`;
                    console.error('Error processing task:', error);
                }
            } finally {
                // Remove completed task from queue
                if (currentTask) {
                    const taskIndex = taskQueue.findIndex(t => t.id === currentTask.id);
                    if (taskIndex !== -1) {
                        taskQueue.splice(taskIndex, 1);
                    }
                }

                currentTask = null;
                currentCategory = taskQueue.length > 0 ? taskQueue[0].task : null;
                updateQueueDisplay();
                
                // Reload history to show updated completion status
                loadHistory();
                
                // Process next task in queue
                setTimeout(() => processNextTask(), 100);
            }
        }

        function updateWorkflowOptions(fileType) {
            const sttCheckbox = document.getElementById('stepStt');
            const sttLabel = sttCheckbox.parentElement;
            
            if (fileType === 'audio') {
                // Show all checkboxes for audio files
                sttLabel.style.display = 'block';
                sttLabel.style.visibility = 'visible';
                sttCheckbox.checked = false;
                sttCheckbox.disabled = false;
            } else if (fileType === 'text') {
                // Hide STT checkbox for text files
                sttLabel.style.display = 'none';
                sttLabel.style.visibility = 'hidden';
                sttCheckbox.checked = false;
                sttCheckbox.disabled = true;
            } else {
                // For unknown types, show all options
                sttLabel.style.display = 'block';
                sttLabel.style.visibility = 'visible';
                sttCheckbox.checked = false;
                sttCheckbox.disabled = false;
            }
            
            // Reset other checkboxes
            document.getElementById('stepCorrect').checked = false;
            document.getElementById('stepSummary').checked = false;
        }

        document.getElementById('uploadBtn').addEventListener('click', async () => {
            const input = document.getElementById('fileInput');
            const status = document.getElementById('status');
            const files = Array.from(input.files);
            if (files.length === 0) {
                status.textContent = 'Please select a file first.';
                return;
            }

            const formData = new FormData();
            files.forEach(f => formData.append('files', f));

            try {
                const resp = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });
                if (resp.ok) {
                    const data = await resp.json();
                    if (data.length === 1) {
                        const fileData = data[0];
                        uploadedPath = fileData.file_path;
                        fileType = fileData.file_type;
                        recordId = fileData.record_id;

                        updateWorkflowOptions(fileType);
                        document.getElementById('workflow').style.display = 'block';

                        if (fileType === 'audio') {
                            status.textContent = 'Upload complete! Select workflow steps.';
                        } else if (fileType === 'text') {
                            status.textContent = 'Upload complete! Select text processing steps.';
                        } else {
                            status.textContent = 'Upload complete! File type not fully supported, but you can try processing.';
                        }
                    } else {
                        status.textContent = `${data.length}개의 파일이 업로드되었습니다. 히스토리에서 작업을 선택하세요.`;
                        document.getElementById('workflow').style.display = 'none';
                    }

                    // Reload history to show the new upload(s)
                    loadHistory();
                    input.value = '';
                } else {
                    status.textContent = 'Upload failed.';
                }
            } catch (err) {
                status.textContent = 'Error: ' + err.message;
            }
        });

        document.getElementById('processBtn').addEventListener('click', async () => {
            if (!uploadedPath) return;

            const steps = [];
            if (document.getElementById('stepStt').checked) steps.push('stt');
            if (document.getElementById('stepCorrect').checked) steps.push('correct');
            if (document.getElementById('stepSummary').checked) steps.push('summary');

            if (steps.length === 0) {
                alert('최소 하나의 작업을 선택해주세요.');
                return;
            }

            const downloads = document.getElementById('downloads');
            downloads.innerHTML = '<p style="color: blue; font-weight: bold;">작업을 큐에 추가합니다...</p>';

            // Find the current file's name for queue display
            const history = await loadHistorySync();
            const currentRecord = history.find(record => record.id === recordId);
            const filename = currentRecord ? currentRecord.filename : 'Unknown File';

            // Add each step to the queue individually
            steps.forEach(step => {
                // Create a temporary task element for queue tracking
                const tempElement = document.createElement('span');
                addTaskToQueue(recordId, uploadedPath, step, tempElement, filename);
            });

            downloads.innerHTML = `<p style="color: green;">선택한 작업들이 큐에 추가되었습니다.</p>`;
            
            // Clear the current upload context
            uploadedPath = null;
            fileType = null;
            recordId = null;
            document.getElementById('workflow').style.display = 'none';
            document.getElementById('fileInput').value = '';
        });

        // Check for running tasks on page load
        async function checkRunningTasks() {
            try {
                const response = await fetch('/tasks');
                if (response.ok) {
                    const runningTasks = await response.json();
                    console.log('Running tasks found:', runningTasks);
                    
                    // If there are running tasks, show a warning
                    if (Object.keys(runningTasks).length > 0) {
                        const status = document.getElementById('status');
                        const taskCount = Object.keys(runningTasks).length;
                        
                        let taskDetails = '';
                        for (const [taskId, info] of Object.entries(runningTasks)) {
                            const duration = Math.round(info.duration || 0);
                            taskDetails += `<li>작업 ID: ${taskId} (실행시간: ${duration}초)</li>`;
                        }
                        
                        status.innerHTML = `
                            <div class="warning-box">
                                <strong>⚠️ 백그라운드에서 실행 중인 작업이 있습니다!</strong><br>
                                페이지를 새로고침했지만 서버에서 ${taskCount}개의 작업이 계속 실행 중입니다.<br>
                                <ul style="margin: 5px 0;">${taskDetails}</ul>
                                작업 완료 후 히스토리를 자동으로 업데이트됩니다.
                            </div>
                        `;
                    }
                }
            } catch (error) {
                console.error('Error checking running tasks:', error);
            }
        }

        // Periodically check for running tasks
        let previousTaskCount = 0;
        function startTaskMonitoring() {
            setInterval(async () => {
                try {
                    const response = await fetch('/tasks');
                    if (response.ok) {
                        const runningTasks = await response.json();
                        const taskCount = Object.keys(runningTasks).length;
                        
                        // Update page title to show running tasks
                        if (taskCount > 0) {
                            document.title = `(${taskCount}) RecordRoute File Upload`;
                        } else {
                            document.title = 'RecordRoute File Upload';
                        }
                        
                        // If task count decreased, some tasks completed - reload history
                        if (previousTaskCount > 0 && taskCount < previousTaskCount) {
                            console.log('Tasks completed, reloading history...');
                            loadHistory();
                            
                            // Clear the warning message if no tasks are running
                            if (taskCount === 0) {
                                const status = document.getElementById('status');
                                if (status.innerHTML.includes('백그라운드에서 실행 중인')) {
                                    status.innerHTML = `
                                        <div style="background: #d4edda; border: 1px solid #c3e6cb; padding: 10px; border-radius: 5px; margin: 10px 0; color: #155724;">
                                            ✅ 모든 백그라운드 작업이 완료되었습니다!
                                        </div>
                                    `;
                                    // Clear this message after 3 seconds
                                    setTimeout(() => {
                                        if (status.innerHTML.includes('모든 백그라운드 작업이 완료')) {
                                            status.innerHTML = '';
                                        }
                                    }, 3000);
                                }
                            }
                        }
                        
                        previousTaskCount = taskCount;
                    }
                } catch (error) {
                    console.error('Error monitoring tasks:', error);
                }
            }, 2000); // Check every 2 seconds
        }

        // Load history on page load
        document.getElementById('searchBtn').addEventListener('click', async () => {
            const q = document.getElementById('searchInput').value.trim();
            if (!q) return;
            try {
                const resp = await fetch(`/search?q=${encodeURIComponent(q)}`);
                if (!resp.ok) throw new Error('검색 실패');
                const data = await resp.json();
                const list = document.getElementById('searchResults');
                list.innerHTML = '';
                if (data.length === 0) {
                    list.innerHTML = '<li>결과 없음</li>';
                } else {
                    data.forEach(item => {
                        const li = document.createElement('li');
                        const a = document.createElement('a');
                        a.href = item.link;
                        a.textContent = `${item.file} (${item.score.toFixed(3)})`;
                        a.target = '_blank';
                        li.appendChild(a);
                        list.appendChild(li);
                    });
                }
            } catch (err) {
                alert(err.message);
            }
        });

        document.addEventListener('DOMContentLoaded', function() {
            loadHistory();
            checkRunningTasks();
            startTaskMonitoring();
        });
    </script>
</body>
</html>
