<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>RecordRoute File Upload</title>
</head>
<body>
    <h1>Upload File</h1>
    <input type="file" id="fileInput" accept="audio/*,.md,.txt,.text,.markdown" />
    <button id="uploadBtn">Upload</button>
    <div id="status"></div>

    <div id="workflow" style="display:none; margin-top:1em;">
        <label><input type="checkbox" id="stepStt" /> STT 변환</label>
        <label><input type="checkbox" id="stepCorrect" /> 텍스트 교정</label>
        <label><input type="checkbox" id="stepSummary" /> 요약</label>
        <button id="processBtn">확인</button>
    </div>

    <div id="downloads" style="margin-top:1em;"></div>

    <div id="queue-section" style="margin-top:2em;">
        <h2>작업 큐</h2>
        <div id="queue-list"></div>
    </div>

    <div id="history-section" style="margin-top:2em;">
        <h2>업로드 기록</h2>
        <div id="history-list"></div>
    </div>

    <script>
        let uploadedPath = null;
        let fileType = null;
        let recordId = null;
        let taskQueue = [];
        let currentTask = null;
        let taskIdCounter = 0;

        function formatDateTime(isoString) {
            const date = new Date(isoString);
            return date.toLocaleString('ko-KR', {
                year: 'numeric',
                month: '2-digit', 
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        }

        function addTaskToQueue(recordId, filePath, task, taskElement, filename) {
            const taskItem = {
                id: ++taskIdCounter,
                recordId: recordId,
                filePath: filePath,
                task: task,
                taskElement: taskElement,
                filename: filename,
                status: 'queued',
                abortController: null
            };
            
            taskQueue.push(taskItem);
            updateQueueDisplay();
            processNextTask();
            
            return taskItem.id;
        }

        function removeTaskFromQueue(taskId) {
            const taskIndex = taskQueue.findIndex(t => t.id === taskId);
            if (taskIndex !== -1) {
                const task = taskQueue[taskIndex];
                
                // Abort the request if it's in progress
                if (task.abortController) {
                    task.abortController.abort();
                }
                
                // Reset task element appearance
                if (task.taskElement) {
                    resetTaskElement(task.taskElement, task.task);
                }
                
                taskQueue.splice(taskIndex, 1);
                updateQueueDisplay();
            }
            
            // If this was the current task, process next
            if (currentTask && currentTask.id === taskId) {
                currentTask = null;
                processNextTask();
            }
        }

        function resetTaskElement(taskElement, task) {
            const taskNames = {
                'stt': 'STT',
                'correct': '교정',
                'summary': '요약'
            };
            
            taskElement.textContent = taskNames[task] || task;
            taskElement.style.backgroundColor = '#6c757d';
            taskElement.style.color = 'white';
            taskElement.style.cursor = 'pointer';
            taskElement.title = '클릭하여 작업 시작';
        }

        function updateQueueDisplay() {
            const queueList = document.getElementById('queue-list');
            queueList.innerHTML = '';
            
            if (taskQueue.length === 0) {
                queueList.innerHTML = '<p style="color: #6c757d; font-style: italic;">진행 중인 작업이 없습니다.</p>';
                return;
            }
            
            taskQueue.forEach((task, index) => {
                const item = document.createElement('div');
                item.style.cssText = `
                    border: 1px solid #dee2e6;
                    border-radius: 5px;
                    padding: 8px 12px;
                    margin-bottom: 5px;
                    background-color: ${task.status === 'processing' ? '#fff3cd' : '#f8f9fa'};
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                `;
                
                const taskNames = {
                    'stt': 'STT 변환',
                    'correct': '텍스트 교정',
                    'summary': '요약'
                };
                
                const statusText = task.status === 'processing' ? '진행중' : `대기중 (${index + 1}번째)`;
                const statusColor = task.status === 'processing' ? '#856404' : '#6c757d';
                
                const info = document.createElement('span');
                info.innerHTML = `
                    <strong>${task.filename}</strong> - ${taskNames[task.task] || task.task}
                    <span style="color: ${statusColor}; font-size: 12px; margin-left: 10px;">[${statusText}]</span>
                `;
                
                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = '×';
                cancelBtn.style.cssText = `
                    background: #dc3545;
                    color: white;
                    border: none;
                    border-radius: 3px;
                    width: 24px;
                    height: 24px;
                    cursor: pointer;
                    font-size: 16px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
                cancelBtn.title = '작업 취소';
                cancelBtn.onclick = () => removeTaskFromQueue(task.id);
                
                item.appendChild(info);
                item.appendChild(cancelBtn);
                queueList.appendChild(item);
            });
        }

        function createTaskElement(task, isCompleted, downloadUrl, record = null) {
            const taskNames = {
                'stt': 'STT',
                'correct': '교정',
                'summary': '요약'
            };
            
            const span = document.createElement('span');
            span.textContent = taskNames[task] || task;
            span.style.margin = '0 5px';
            span.style.padding = '2px 6px';
            span.style.borderRadius = '3px';
            span.style.fontSize = '12px';
            
            if (isCompleted && downloadUrl) {
                // Completed task - green with download link
                span.style.backgroundColor = '#28a745';
                span.style.color = 'white';
                span.style.cursor = 'pointer';
                span.style.textDecoration = 'underline';
                span.title = '클릭하여 다운로드';
                span.onclick = () => {
                    window.open(downloadUrl, '_blank');
                };
            } else if (record) {
                // Incomplete task - clickable to add to queue
                span.style.backgroundColor = '#6c757d';
                span.style.color = 'white';
                span.style.cursor = 'pointer';
                span.title = '클릭하여 작업 시작';
                span.onclick = () => {
                    // Check if this task is already in queue
                    const existingTask = taskQueue.find(t => 
                        t.recordId === record.id && 
                        t.task === task
                    );
                    
                    if (!existingTask) {
                        addTaskToQueue(record.id, record.file_path, task, span, record.filename);
                        
                        // Show queued state
                        span.style.backgroundColor = '#17a2b8';
                        span.style.color = 'white';
                        span.title = '큐에 추가됨';
                        span.onclick = null;
                    }
                };
            } else {
                // Default state - not clickable
                span.style.backgroundColor = '#e9ecef';
                span.style.color = '#6c757d';
            }
            
            return span;
        }

        function displayHistory(history) {
            const historyList = document.getElementById('history-list');
            historyList.innerHTML = '';
            
            if (history.length === 0) {
                historyList.innerHTML = '<p style="color: #6c757d; font-style: italic;">업로드 기록이 없습니다.</p>';
                return;
            }
            
            history.forEach(record => {
                const item = document.createElement('div');
                item.style.cssText = `
                    border: 1px solid #dee2e6;
                    border-radius: 5px;
                    padding: 10px;
                    margin-bottom: 10px;
                    background-color: #f8f9fa;
                `;
                
                const typeLabel = record.file_type === 'audio' ? '오디오' : '텍스트';
                const dateTime = formatDateTime(record.timestamp);
                const duration = record.duration ? ` ${record.duration}` : '';
                
                const header = document.createElement('div');
                header.style.marginBottom = '5px';
                header.innerHTML = `
                    <strong>[${typeLabel}]</strong> 
                    ${dateTime} 
                    <strong>${record.filename}</strong>${duration}
                `;
                
                const tasks = document.createElement('div');
                
                // Only show STT button for audio files
                if (record.file_type === 'audio') {
                    tasks.appendChild(createTaskElement('stt', record.completed_tasks.stt, record.download_links.stt, record));
                }
                
                tasks.appendChild(createTaskElement('correct', record.completed_tasks.correct, record.download_links.correct, record));
                tasks.appendChild(createTaskElement('summary', record.completed_tasks.summary, record.download_links.summary, record));
                
                item.appendChild(header);
                item.appendChild(tasks);
                historyList.appendChild(item);
            });
        }

        async function loadHistory() {
            try {
                const response = await fetch('/history');
                if (response.ok) {
                    const history = await response.json();
                    displayHistory(history);
                } else {
                    console.error('Failed to load history');
                }
            } catch (error) {
                console.error('Error loading history:', error);
            }
        }

        async function loadHistorySync() {
            try {
                const response = await fetch('/history');
                if (response.ok) {
                    return await response.json();
                }
                return [];
            } catch (error) {
                console.error('Error loading history:', error);
                return [];
            }
        }

        async function processNextTask() {
            if (currentTask || taskQueue.length === 0) {
                return;
            }
            
            currentTask = taskQueue[0];
            currentTask.status = 'processing';
            updateQueueDisplay();
            
            try {
                // Show loading state on the task element
                const taskElement = currentTask.taskElement;
                const originalText = taskElement.textContent;
                taskElement.textContent = '처리중...';
                taskElement.style.backgroundColor = '#ffc107';
                taskElement.style.color = 'black';
                taskElement.style.cursor = 'default';
                taskElement.onclick = null;

                // Create AbortController for this task
                currentTask.abortController = new AbortController();

                const response = await fetch('/process', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        file_path: currentTask.filePath, 
                        steps: [currentTask.task],
                        record_id: currentTask.recordId
                    }),
                    signal: currentTask.abortController.signal
                });

                if (response.ok) {
                    const result = await response.json();
                    
                    if (result.error) {
                        // Show error state
                        taskElement.textContent = '오류';
                        taskElement.style.backgroundColor = '#dc3545';
                        taskElement.style.color = 'white';
                        taskElement.title = `오류: ${result.error}`;
                    } else if (result[currentTask.task]) {
                        // Show success state with download link
                        taskElement.textContent = originalText;
                        taskElement.style.backgroundColor = '#28a745';
                        taskElement.style.color = 'white';
                        taskElement.style.cursor = 'pointer';
                        taskElement.style.textDecoration = 'underline';
                        taskElement.title = '클릭하여 다운로드';
                        taskElement.onclick = () => {
                            window.open(result[currentTask.task], '_blank');
                        };
                    }
                } else {
                    // Show error state
                    taskElement.textContent = '오류';
                    taskElement.style.backgroundColor = '#dc3545';
                    taskElement.style.color = 'white';
                    taskElement.title = '처리 중 오류가 발생했습니다';
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('Task was cancelled');
                } else {
                    // Show error state
                    const taskElement = currentTask.taskElement;
                    taskElement.textContent = '오류';
                    taskElement.style.backgroundColor = '#dc3545';
                    taskElement.style.color = 'white';
                    taskElement.title = `오류: ${error.message}`;
                    console.error('Error processing task:', error);
                }
            } finally {
                // Remove completed task from queue
                if (currentTask) {
                    const taskIndex = taskQueue.findIndex(t => t.id === currentTask.id);
                    if (taskIndex !== -1) {
                        taskQueue.splice(taskIndex, 1);
                    }
                }
                
                currentTask = null;
                updateQueueDisplay();
                
                // Reload history to show updated completion status
                loadHistory();
                
                // Process next task in queue
                setTimeout(() => processNextTask(), 100);
            }
        }

        function updateWorkflowOptions(fileType) {
            const sttCheckbox = document.getElementById('stepStt');
            const sttLabel = sttCheckbox.parentElement;
            
            if (fileType === 'audio') {
                // Show all checkboxes for audio files
                sttLabel.style.display = 'block';
                sttLabel.style.visibility = 'visible';
                sttCheckbox.checked = false;
                sttCheckbox.disabled = false;
            } else if (fileType === 'text') {
                // Hide STT checkbox for text files
                sttLabel.style.display = 'none';
                sttLabel.style.visibility = 'hidden';
                sttCheckbox.checked = false;
                sttCheckbox.disabled = true;
            } else {
                // For unknown types, show all options
                sttLabel.style.display = 'block';
                sttLabel.style.visibility = 'visible';
                sttCheckbox.checked = false;
                sttCheckbox.disabled = false;
            }
            
            // Reset other checkboxes
            document.getElementById('stepCorrect').checked = false;
            document.getElementById('stepSummary').checked = false;
        }

        document.getElementById('uploadBtn').addEventListener('click', async () => {
            const input = document.getElementById('fileInput');
            const status = document.getElementById('status');
            if (!input.files.length) {
                status.textContent = 'Please select a file first.';
                return;
            }
            const formData = new FormData();
            formData.append('file', input.files[0]);
            try {
                const resp = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });
                if (resp.ok) {
                    const data = await resp.json();
                    uploadedPath = data.file_path;
                    fileType = data.file_type;
                    recordId = data.record_id;
                    
                    updateWorkflowOptions(fileType);
                    document.getElementById('workflow').style.display = 'block';
                    
                    // Reload history to show the new upload
                    loadHistory();
                    
                    if (fileType === 'audio') {
                        status.textContent = 'Upload complete! Select workflow steps.';
                    } else if (fileType === 'text') {
                        status.textContent = 'Upload complete! Select text processing steps.';
                    } else {
                        status.textContent = 'Upload complete! File type not fully supported, but you can try processing.';
                    }
                } else {
                    status.textContent = 'Upload failed.';
                }
            } catch (err) {
                status.textContent = 'Error: ' + err.message;
            }
        });

        document.getElementById('processBtn').addEventListener('click', async () => {
            if (!uploadedPath) return;

            const steps = [];
            if (document.getElementById('stepStt').checked) steps.push('stt');
            if (document.getElementById('stepCorrect').checked) steps.push('correct');
            if (document.getElementById('stepSummary').checked) steps.push('summary');

            if (steps.length === 0) {
                alert('최소 하나의 작업을 선택해주세요.');
                return;
            }

            const downloads = document.getElementById('downloads');
            downloads.innerHTML = '<p style="color: blue; font-weight: bold;">작업을 큐에 추가합니다...</p>';

            // Find the current file's name for queue display
            const history = await loadHistorySync();
            const currentRecord = history.find(record => record.id === recordId);
            const filename = currentRecord ? currentRecord.filename : 'Unknown File';

            // Add each step to the queue individually
            steps.forEach(step => {
                // Create a temporary task element for queue tracking
                const tempElement = document.createElement('span');
                addTaskToQueue(recordId, uploadedPath, step, tempElement, filename);
            });

            downloads.innerHTML = `<p style="color: green;">선택한 작업들이 큐에 추가되었습니다.</p>`;
            
            // Clear the current upload context
            uploadedPath = null;
            fileType = null;
            recordId = null;
            document.getElementById('workflow').style.display = 'none';
            document.getElementById('fileInput').value = '';
        });

        // Load history on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadHistory();
        });
    </script>
</body>
</html>
